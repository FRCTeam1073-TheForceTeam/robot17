// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1073.robot17.commands;
import edu.wpi.first.wpilibj.Relay.Value;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc1073.robot17.Robot;
import org.usfirst.frc1073.robot17.RobotMap;

/**
 *
 */
public class TestAllsystems extends Command {

	double resetMotor = 0;
	double leftEnc = (RobotMap.driveTrainleftEnc.get()/4)/1440;
	double rightEnc = (RobotMap.driveTrainrightEnc.get()/4)/1440;
	double leftEnc2 = (RobotMap.driveTrainleftEnc.get()/4)/1440;
	double rightEnc2 = (RobotMap.driveTrainrightEnc.get()/4)/1440;
	double testSpeedPositive = 0.5;
	double testSpeedNegative = 0 - 0-5;
	double climberEnc2 = RobotMap.climberclimberEncoder.get();
	double launcherEnc2 = RobotMap.launcherlauncherEncoder.get();
	double climberEnc = RobotMap.climberclimberEncoder.get();
	double launcherEnc = RobotMap.launcherlauncherEncoder.get();
	long testTime = 5000L;
	long printTime = 60000L;
	double positiveUpper = 25;
	double positiveLower = 15;
	double negativeUpper = -15;
	double negativeLower = -25;
	double testGyroLow = 1;
	double testGyroHigh = 150;
	double testProx = .1;
	double testLaunch = .001;
	double zero = 0;
	double collectorPositive = .05;
	double collectorNegative = 0 - .05;
	double testCollectorPositive = 0;
	double testCollectorNegative = 0;
	double spike1testPositive = 0.05;
	double spike1testNegative = 0-.5;
	double spike2testPositive = .05;
	double spike2testNegative = 0-.5;
	double testLauncherPositive = .05;
	double testLauncherNegative = 0 - .05;
	double LauncherMax = .001;
	double LauncherMin = 0;
	double climberMax = .001;
	double climberMin = 0;
	double testClimberPositive = .05;
	double testClimberNegative = 0-.05;
	
		
	
	
	//value will be used to set all motors to 0 (essentially to reset)
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public TestAllsystems() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	RobotMap.driveTrainleftEnc.reset();
    	RobotMap.driveTrainrightEnc.reset();
    	RobotMap.climberclimberEncoder.reset();
    	RobotMap.launcherlauncherEncoder.reset();
    	//reset encoders
    	RobotMap.driveTrainHeadingGyro.reset();
    	//reset gyroscope
    	RobotMap.driveTrainProximitySensorFront.resetAccumulator();
    	//reset proximity sensor
    	RobotMap.launcherconveyorMotor.set(resetMotor);
    	RobotMap.launcherconveyorMotor.set(resetMotor);
    	RobotMap.collectorcollectorMotor.set(resetMotor);
    	RobotMap.lEDsspike1.stopMotor();
    	RobotMap.lEDsspike2.stopMotor();
    	RobotMap.driveTrainleftMotor1.set(resetMotor);
    	RobotMap.driveTrainleftMotor2.set(resetMotor);
    	RobotMap.driveTrainleftMotor3.set(resetMotor);
    	RobotMap.driveTrainrightMotor1.set(resetMotor);
    	RobotMap.driveTrainrightMotor2.set(resetMotor);
    	RobotMap.driveTrainrightMotor3.set(resetMotor);
    	RobotMap.launcherlauncherMotor1.set(resetMotor);
    	RobotMap.climberclimber.set(resetMotor);
    	//reset motors
    	
    	//reset all motors and encoders so that they are at a state of rest. No motors are moving and no encoders are holding a value.
    	
    	
    	
    	
    
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	RobotMap.driveTrainleftMotor1.set(testSpeedPositive);
    	RobotMap.driveTrainleftMotor2.set(testSpeedPositive);
    	RobotMap.driveTrainleftMotor3.set(testSpeedPositive);
    	try {
			Thread.sleep(testTime);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	RobotMap.driveTrainleftMotor1.set(resetMotor);
    	RobotMap.driveTrainleftMotor2.set(resetMotor);
    	RobotMap.driveTrainleftMotor3.set(resetMotor);
    	if (leftEnc > positiveUpper || leftEnc < positiveLower) {
    		SmartDashboard.putBoolean("left motors forward", true);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		
    	}
    	else {
    		SmartDashboard.putBoolean("left motors forward", false);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    	}
    	//tests for the left motors to be moving forward properly
    	RobotMap.driveTrainleftMotor1.set(testSpeedNegative);
    	RobotMap.driveTrainleftMotor2.set(testSpeedNegative);
    	RobotMap.driveTrainleftMotor3.set(testSpeedNegative);
    	try {
			Thread.sleep(testTime);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	RobotMap.driveTrainleftMotor1.set(resetMotor);
    	RobotMap.driveTrainleftMotor2.set(resetMotor);
    	RobotMap.driveTrainleftMotor3.set(resetMotor);
    	if (leftEnc2 > negativeLower || leftEnc2 < negativeUpper) {
    		
    		SmartDashboard.putBoolean("left motors backward", true);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    	}
    	else {
    		SmartDashboard.putBoolean("left motors backward", false);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    	}
    	
    
    	//tests for the left motors to be moving backwards properly
    	
       
        	RobotMap.driveTrainrightMotor1.set(testSpeedPositive);
        	RobotMap.driveTrainrightMotor2.set(testSpeedPositive);
        	RobotMap.driveTrainrightMotor3.set(testSpeedPositive);
        	try {
    			Thread.sleep(testTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
        	RobotMap.driveTrainrightMotor1.set(resetMotor);
        	RobotMap.driveTrainrightMotor2.set(resetMotor);
        	RobotMap.driveTrainrightMotor3.set(resetMotor);
        	if (rightEnc > positiveUpper  || rightEnc < positiveLower) {
        		SmartDashboard.putBoolean("right motors forward", true);
        		try {
        			Thread.sleep(printTime);
        		} catch (InterruptedException e) {
        			// TODO Auto-generated catch block
        			e.printStackTrace();
        		}
        	}
        	else {
        		SmartDashboard.putBoolean("right motors forward", false);
        		try {
        			Thread.sleep(printTime);
        		} catch (InterruptedException e) {
        			// TODO Auto-generated catch block
        			e.printStackTrace();
        		}
        	}
        	//tests for the left motors to be moving forward properly
        	RobotMap.driveTrainrightMotor1.set(testSpeedNegative);
        	RobotMap.driveTrainrightMotor2.set(testSpeedNegative);
        	RobotMap.driveTrainrightMotor3.set(testSpeedNegative);
        	try {
    			Thread.sleep(testTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
        	RobotMap.driveTrainrightMotor1.set(resetMotor);
        	RobotMap.driveTrainrightMotor2.set(resetMotor);
        	RobotMap.driveTrainrightMotor3.set(resetMotor);
        	if (rightEnc2 > negativeLower || rightEnc2 < negativeUpper) {
        		
        		SmartDashboard.putBoolean(" right motors backward", true);
        		try {
        			Thread.sleep(printTime);
        		} catch (InterruptedException e) {
        			// TODO Auto-generated catch block
        			e.printStackTrace();
        		}
        		
        	}
        	else {
        		SmartDashboard.putBoolean("right motors backward", false);
        		try {
        			Thread.sleep(printTime);
        		} catch (InterruptedException e) {
        			// TODO Auto-generated catch block
        			e.printStackTrace();
        		}
        		//tests for the right motors to move backwards properly
        	}
    	
    		if (RobotMap.driveTrainleftMotor1.getOutputVoltage()>0.001);
    		SmartDashboard.putBoolean("leftmotor 1", true);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		
    		
    		
    		{			 
				SmartDashboard.putBoolean("leftmotor1", false);
				try {
	    			Thread.sleep(printTime);
	    		} catch (InterruptedException e) {
	    			// TODO Auto-generated catch block
	    			e.printStackTrace();
	    		}
				//tests forward for left motor one
				
			}if (RobotMap.driveTrainleftMotor2.getOutputVoltage()>0.001);
    		SmartDashboard.putBoolean("leftmotor 2", true);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		
    		
    		
    		{			 
				SmartDashboard.putBoolean("leftmotor 2", false);
				try {
	    			Thread.sleep(printTime);
	    		} catch (InterruptedException e) {
	    			// TODO Auto-generated catch block
	    			e.printStackTrace();
	    		}
				//tests forward for left motor two
			}
    		if (RobotMap.driveTrainleftMotor3.getOutputVoltage()>0.001);
    		SmartDashboard.putBoolean("leftmotor 3", true);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		
    		
    		
    		{			 
				SmartDashboard.putBoolean("leftmotor 3", false);
				try {
	    			Thread.sleep(printTime);
	    		} catch (InterruptedException e) {
	    			// TODO Auto-generated catch block
	    			e.printStackTrace();
	    		}
				//tests forward for left motor three
			}
    		if (RobotMap.driveTrainrightMotor1.getOutputVoltage()>0.001);
    		SmartDashboard.putBoolean("rightmotor 1", true);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		
    		
    		
    		{			 
				SmartDashboard.putBoolean("rightmotor1", false);
				try {
	    			Thread.sleep(printTime);
	    		} catch (InterruptedException e) {
	    			// TODO Auto-generated catch block
	    			e.printStackTrace();
	    		}
				
			}
    		if (RobotMap.driveTrainrightMotor2.getOutputVoltage()>0.001);
    		SmartDashboard.putBoolean("rightmotor 2", true);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		
    		
    		
    		{			 
				SmartDashboard.putBoolean("rightmotor2", false);
				try {
	    			Thread.sleep(printTime);
	    		} catch (InterruptedException e) {
	    			// TODO Auto-generated catch block
	    			e.printStackTrace();
	    		}
				//tests forward for right motor 2
			}
    		if (RobotMap.driveTrainrightMotor3.getOutputVoltage()>0.001);
    		SmartDashboard.putBoolean("rightmotor 3", true);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		
    		
    		
    		{			 
				SmartDashboard.putBoolean("rightmotor3", false);
				try {
	    			Thread.sleep(printTime);
	    		} catch (InterruptedException e) {
	    			// TODO Auto-generated catch block
	    			e.printStackTrace();
	    		}
				
			//tests forward for right motor three
			}
    		if (RobotMap.driveTrainHeadingGyro.getAngle() < testGyroLow || RobotMap.driveTrainHeadingGyro.getAngle() > testGyroHigh) ;
    		SmartDashboard.putBoolean("gyroscope", true); 
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		
    		
    		
    		{			 
				SmartDashboard.putBoolean("gyroscope", false);
				try {
	    			Thread.sleep(printTime);
	    		} catch (InterruptedException e) {
	    			// TODO Auto-generated catch block
	    			e.printStackTrace();
	    		}
				//tests gyroscope
    		}
    		
        	if (RobotMap.driveTrainProximitySensorFront.getAccumulatorValue() > testProx);
        	SmartDashboard.putBoolean("Proximity Sensor", true); 
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		
    		
    		
    		{			 
				SmartDashboard.putBoolean("Proximity Sensor", false);
				try {
	    			Thread.sleep(printTime);
	    		} catch (InterruptedException e) {
	    			// TODO Auto-generated catch block
	    			e.printStackTrace();
	    		}
				//tests proximity sensor
    		}
    		RobotMap.launcherconveyorMotor.set(testSpeedPositive);
    		try {
    			Thread.sleep(testTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		if (RobotMap.launcherconveyorMotor.get()> testLaunch);
    		SmartDashboard.putBoolean("launcher conveyor forward", true);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		
    		
    		
    		{			 
				SmartDashboard.putBoolean("launcher conveyor forward", false);
				try {
	    			Thread.sleep(printTime);
	    		} catch (InterruptedException e) {
	    			// TODO Auto-generated catch block
	    			e.printStackTrace();
	    		}
				//tests launcher motor forward
			}
    		RobotMap.launcherconveyorMotor.set(resetMotor);
    		try {
    			Thread.sleep(testTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    			//resets launcher motor
    		}
    		RobotMap.launcherconveyorMotor.set(testSpeedNegative);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		if (RobotMap.launcherconveyorMotor.get() < zero);
    		SmartDashboard.putBoolean("launcher conveyor backward", true);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		//tests launcher motor backward
    		RobotMap.collectorcollectorMotor.set(collectorPositive);
    		try {
    			Thread.sleep(testTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		if (RobotMap.collectorcollectorMotor.get()> testCollectorPositive);
    		SmartDashboard.putBoolean("collector forward", true);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    	
    		{			 
				SmartDashboard.putBoolean("collector forward", false);
				try {
	    			Thread.sleep(printTime);
	    		} catch (InterruptedException e6) {
	    			// TODO Auto-generated catch block
	    			e6.printStackTrace();
	    		}
				//tests collector forward
			}
    		RobotMap.collectorcollectorMotor.set(resetMotor);
    		try {
    			Thread.sleep(testTime);
    		} catch (InterruptedException e5) {
    			// TODO Auto-generated catch block
    			e5.printStackTrace();
    		}
    		//resets collector motor
    		RobotMap.collectorcollectorMotor.set(testCollectorNegative);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e4) {
    			// TODO Auto-generated catch block
    			e4.printStackTrace();
    		}
    		if (RobotMap.collectorcollectorMotor.get() < testCollectorNegative);
    		SmartDashboard.putBoolean("collecctor backward", true);
    		try {
    			Thread.sleep(printTime);
    		} catch (InterruptedException e3) {
    			// TODO Auto-generated catch block
    			e3.printStackTrace();
    		}
    		
    		
    		{			 
				SmartDashboard.putBoolean("collector backward", false);
				try {
	    			Thread.sleep(printTime);
	    		} catch (InterruptedException e2) {
	    			// TODO Auto-generated catch block
	    			e2.printStackTrace();
	    		}
				//tests collector backward
				if (RobotMap.lEDsspike1.isAlive() == true);
				SmartDashboard.putBoolean("LED Spike 1", true);
	    		try {
	    			Thread.sleep(printTime);
	    		} catch (InterruptedException e3) {
	    			// TODO Auto-generated catch block
	    			e3.printStackTrace();
	    		}
	    		
	    		
	    		{			 
					SmartDashboard.putBoolean("LED Spike 1", false);
					try {
		    			Thread.sleep(printTime);
		    		} catch (InterruptedException e2) {
		    			// TODO Auto-generated catch block
		    			e2.printStackTrace();
		    		}
				
					// test LED Spike 1 
					if (RobotMap.lEDsspike2.isAlive() == true);
					SmartDashboard.putBoolean("LED Spike 2", true);
		    		try {
		    			Thread.sleep(printTime);
		    		} catch (InterruptedException e3) {
		    			// TODO Auto-generated catch block
		    			e3.printStackTrace();
		    		}
		    		
		    		
		    		{			 
						SmartDashboard.putBoolean("LED Spike 2", false);
						try {
			    			Thread.sleep(printTime);
			    		} catch (InterruptedException e2) {
			    			// TODO Auto-generated catch block
			    			e2.printStackTrace();
			    		}
						
						//test LED Spike 2
						
						RobotMap.launcherlauncherMotor1.set(testLauncherPositive);
						if (RobotMap.launcherlauncherMotor1.getOutputVoltage() > LauncherMax);
						SmartDashboard.putBoolean("launcher motor forward", true);
			    		try {
			    			Thread.sleep(printTime);
			    		} catch (InterruptedException e3) {
			    			// TODO Auto-generated catch block
			    			e3.printStackTrace();
			    		}
			    		
			    		
			    		{			 
							SmartDashboard.putBoolean("launcher motor forward", false);
							try {
				    			Thread.sleep(printTime);
				    		} catch (InterruptedException e2) {
				    			e2.printStackTrace();
				    		}
						//
							//
							RobotMap.launcherlauncherMotor1.set(testLauncherNegative);
							if (RobotMap.launcherlauncherMotor1.getOutputVoltage() > LauncherMin);
							SmartDashboard.putBoolean("launcher motor back", true);
				    		try {
				    			Thread.sleep(printTime);
				    		} catch (InterruptedException e1) {
				    			// TODO Auto-generated catch block
				    			e1.printStackTrace();
				    		}
				    		
				    		
				    		{			 
								SmartDashboard.putBoolean("launcher motor back", false);
								try {
					    			Thread.sleep(printTime);
					    		} catch (InterruptedException e1) {
					    			e1.printStackTrace();
					    		}
								//
								//
								//
								if (launcherEnc > positiveUpper || launcherEnc < positiveLower) {
						    		
						    		SmartDashboard.putBoolean("launcher encoder forward", true);
						    		try {
						    			Thread.sleep(printTime);
						    		} catch (InterruptedException e1) {
						    			// TODO Auto-generated catch block
						    			e1.printStackTrace();
						    		}
						    	}
						    	else {
						    		SmartDashboard.putBoolean("launcher encoder forward", false);
						    		try {
						    			Thread.sleep(printTime);
						    		} catch (InterruptedException e1) {
						    			// TODO Auto-generated catch block
						    			e1.printStackTrace();
						    		}
						    	}
								if (launcherEnc2 > negativeLower || launcherEnc2 < negativeUpper);
								{
					        		
					        		SmartDashboard.putBoolean(" launcher encoder backward", true);
					        		try {
					        			Thread.sleep(printTime);
					        		} catch (InterruptedException e1) {
					        			// TODO Auto-generated catch block
					        			e1.printStackTrace();
					        		}
					        		
					        	}
					        	 {
					        		SmartDashboard.putBoolean("launcher encoder backward", false);
					        		try {
					        			Thread.sleep(printTime);
					        		} catch (InterruptedException e1) {
					        			// TODO Auto-generated catch block
					        			e1.printStackTrace();
					        		}
				//
					        		//
					        		//
					        		//
					        		//
					        		RobotMap.climberclimber.set(testClimberPositive);
									if (RobotMap.launcherlauncherMotor1.getOutputVoltage() > climberMax);
									SmartDashboard.putBoolean("climber forward", true);
						    		try {
						    			Thread.sleep(printTime);
						    		} catch (InterruptedException e3) {
						    			// TODO Auto-generated catch block
						    			e3.printStackTrace();
						    		}
						    		
						    		
						    		{			 
										SmartDashboard.putBoolean("climber forward", false);
										try {
							    			Thread.sleep(printTime);
							    		} catch (InterruptedException e2) {
							    			e2.printStackTrace();
							    		}
									//
										//
										RobotMap.launcherlauncherMotor1.set(testClimberNegative);
										if (RobotMap.launcherlauncherMotor1.getOutputVoltage() > climberMin);
										SmartDashboard.putBoolean("climber back", true);
							    		try {
							    			Thread.sleep(printTime);
							    		} catch (InterruptedException e1) {
							    			// TODO Auto-generated catch block
							    			e1.printStackTrace();
							    		}
							    		
							    		
							    		{			 
											SmartDashboard.putBoolean("climber back", false);
											try {
								    			Thread.sleep(printTime);
								    		} catch (InterruptedException e1) {
								    			e1.printStackTrace();
								    		}
											//
											//
											//
											if (climberEnc > positiveUpper || climberEnc < positiveLower) {
									    		
									    		SmartDashboard.putBoolean("climber encoder forward", true);
									    		try {
									    			Thread.sleep(printTime);
									    		} catch (InterruptedException e1) {
									    			// TODO Auto-generated catch block
									    			e1.printStackTrace();
									    		}
									    	}
									    	else {
									    		SmartDashboard.putBoolean("climber encoder forward", false);
									    		try {
									    			Thread.sleep(printTime);
									    		} catch (InterruptedException e1) {
									    			// TODO Auto-generated catch block
									    			e1.printStackTrace();
									    		}
									    	}
											if (climberEnc2 > negativeLower || climberEnc2 < negativeUpper);
											{
								        		
								        		SmartDashboard.putBoolean(" climber backward", true);
								        		try {
								        			Thread.sleep(printTime);
								        		} catch (InterruptedException e1) {
								        			// TODO Auto-generated catch block
								        			e1.printStackTrace();
								        		}
								        		
								        	}
								        	 {
								        		SmartDashboard.putBoolean("climber backward", false);
								        		try {
								        			Thread.sleep(printTime);
								        		} catch (InterruptedException e1) {
								        			// TODO Auto-generated catch block
								        			e1.printStackTrace();
								        		}
		    		}
		    		}
    		}
    		}
    		}
    		}
    		}
	    		}
    		}
    		}
    		
    		
    		
    		
    		
    		
    		
    }
    

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    	RobotMap.driveTrainleftEnc.reset();
    	RobotMap.driveTrainrightEnc.reset();
    	RobotMap.climberclimberEncoder.reset();
    	RobotMap.launcherlauncherEncoder.reset();
    	//reset encoders
    	RobotMap.driveTrainHeadingGyro.reset();
    	//reset gyroscope
    	RobotMap.driveTrainProximitySensorFront.resetAccumulator();
    	//reset proximity sensor
    	RobotMap.launcherconveyorMotor.set(resetMotor);
    	RobotMap.launcherconveyorMotor.set(resetMotor);
    	RobotMap.collectorcollectorMotor.set(resetMotor);
    	RobotMap.lEDsspike1.stopMotor();
    	RobotMap.lEDsspike2.stopMotor();
    	RobotMap.driveTrainleftMotor1.set(resetMotor);
    	RobotMap.driveTrainleftMotor2.set(resetMotor);
    	RobotMap.driveTrainleftMotor3.set(resetMotor);
    	RobotMap.driveTrainrightMotor1.set(resetMotor);
    	RobotMap.driveTrainrightMotor2.set(resetMotor);
    	RobotMap.driveTrainrightMotor3.set(resetMotor);
    	RobotMap.launcherlauncherMotor1.set(resetMotor);
    	RobotMap.climberclimber.set(resetMotor);
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    	SmartDashboard.getData("OH NO!");
    }
}
