// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1073.robot17.commands;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc1073.robot17.Robot;
import edu.wpi.first.wpilibj.networktables.NetworkTable;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class DriveToBoiler extends Command {
	NetworkTable netTable;
    double xDeltaHG;
    double xWidthHG;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveToBoiler() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        netTable = NetworkTable.getTable("VisionTable");
    
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	SmartDashboard.putString("DriveToBoiler - state", "initialize");
    }


// Called repeatedly when this Command is scheduled to run
protected void execute() {
	SmartDashboard.putString("DriveToBoiler - state", "execute");
	// Get the numbers and print them on the smart dashboard
	double pixToInchHG = ((3.53497*Math.pow(10,(-6* Math.pow(xDeltaHG, 4))))-(8.87729*Math.pow(10,(-4 * Math.pow(xDeltaHG, 3))))+(0.0772* Math.pow(xDeltaHG, 2))-(3.161183*xDeltaHG)+64.26833);
    xDeltaHG =  netTable.getNumber("centerDistHG", 0);
    xWidthHG =  netTable.getNumber("AverageWidthHG", 0);
	SmartDashboard.putNumber("inches awayHG", pixToInchHG);
	SmartDashboard.putNumber("feet awayHG", pixToInchHG / 1);
    SmartDashboard.putNumber("DriveToBoiler xDeltaHG", xDeltaHG);
    SmartDashboard.putNumber("DriveToBoiler widthAvgHG", xWidthHG);
    double initialMultiplierHG = 4;
    double leftHG = 0;
    double rightHG = 0;
    //This is the basic speed - start slow
	double driveSpeedHG = 1;
	double driveSpeedMultiplierHG = 0.2;
	double centerWindow = 10;

	// Get lined up
    if (xDeltaHG > centerWindow) {
    	leftHG = driveSpeedHG*driveSpeedMultiplierHG;
    	rightHG = -driveSpeedHG*driveSpeedMultiplierHG;
    	SmartDashboard.putString("DirectionHG", "LeftHG");
    }
    else if (xDeltaHG < -centerWindow) {
    	leftHG = -driveSpeedHG*driveSpeedMultiplierHG;
    	rightHG = driveSpeedHG*driveSpeedMultiplierHG;
    	SmartDashboard.putString("DirectionHG", "RightHG");
    }
    else {
    	leftHG = 0;
    	rightHG = 0;
    	SmartDashboard.putString("DirectionHG", "CenterHG");
    }

  
    Robot.driveTrain.basicDrive(-leftHG, -rightHG);
    SmartDashboard.putNumber("leftHG", leftHG);
    SmartDashboard.putNumber("rightHG", rightHG);
    //SmartDashboard.putNumber("distanceHG", distanceHG);
    
}
    // Called repeatedly when this Command is scheduled to run
   
    protected boolean isFinished() {
    	//test 1 - known width
   	if ((xDeltaHG < 2) && (xDeltaHG > -2)) {
    		Robot.driveTrain.basicDrive(0, 0);
    	
    		return true;
    	}
    	else {
    		return false;
    }
    	//test 2 - distance
    	//copy from above
    }
    // Called once after isFinished returns true
    

    // Called once after isFinished returns true
    protected void end() {
    	SmartDashboard.putString("DriveToBoiler - state", "end");
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
}
